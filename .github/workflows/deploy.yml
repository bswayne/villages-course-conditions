name: Deploy Villages Conditions App

on:
  push:
    branches: [main] # Trigger on push to main branch

# Define environment variables usable across jobs
env:
  # Replace with your Vault address
  VAULT_ADDR: https://vault.bcjs.us
  # Replace with your Vault role for GitHub Actions
  VAULT_ROLE: github-actions-role
  # Define paths to secrets in Vault
  BACKEND_SECRETS_PATH: secret/data/ci/villages-conditions/backend
  FRONTEND_SECRETS_PATH: secret/data/ci/villages-conditions/frontend
  # Define image names (replace with your registry if using one, e.g., ghcr.io/your-user/...)
  BACKEND_IMAGE_NAME: villages-conditions-backend
  FRONTEND_IMAGE_NAME: villages-conditions-frontend
  # Define tag (using commit SHA is good practice)
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for Vault OIDC auth
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # 1. Authenticate to Vault using OIDC Token
    - name: Request GitHub OIDC token
      id: oidc
      run: |
        TOKEN=$(curl -fsSL -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
          "$ACTIONS_ID_TOKEN_REQUEST_URL" | jq -r .value)
        if [ -z "$TOKEN" ]; then echo "::error::Failed to get OIDC token"; exit 1; fi
        ENCODED_TOKEN=$(echo -n "$TOKEN" | base64 -w0) # Use base64 encoding
        echo "OIDC_TOKEN=${TOKEN}" >> $GITHUB_ENV
        echo "::add-mask::${TOKEN}" # Mask the OIDC token itself

    - name: Authenticate to Vault
      id: vault-login
      run: |
        echo "Attempting Vault login to ${{ env.VAULT_ADDR }} with role ${{ env.VAULT_ROLE }}"
        RESPONSE=$(curl -fsS --request POST ${{ env.VAULT_ADDR }}/v1/auth/jwt/login \
          --data "{\"jwt\": \"$OIDC_TOKEN\", \"role\": \"${{ env.VAULT_ROLE }}\"}")
        # Check for successful response before trying to parse token
        if echo "$RESPONSE" | jq -e '.auth.client_token' > /dev/null; then
          VAULT_TOKEN=$(echo "$RESPONSE" | jq -r '.auth.client_token')
          echo "Vault login successful."
          echo "VAULT_TOKEN=$VAULT_TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$VAULT_TOKEN" # Mask the Vault token
        else
          echo "::error::Vault login failed. Response:"
          echo "$RESPONSE"
          exit 1
        fi

    # 2. Fetch Secrets from Vault
    - name: Fetch Backend Secrets from Vault
      id: fetch-backend-secrets
      run: |
        echo "Fetching secrets from ${{ env.BACKEND_SECRETS_PATH }}"
        SECRET_RESPONSE=$(curl -fsS -H "X-Vault-Token: $VAULT_TOKEN" \
             "${{ env.VAULT_ADDR }}/v1/${{ env.BACKEND_SECRETS_PATH }}")
        
        if ! echo "$SECRET_RESPONSE" | jq -e '.data.data' > /dev/null; then
          echo "::error::Failed to fetch backend secrets or data is empty. Response:"
          echo "$SECRET_RESPONSE"
          exit 1
        fi

        FIREBASE_JSON=$(echo "$SECRET_RESPONSE" | jq -r '.data.data.FIREBASE_ADMIN_SDK_JSON')
        FRONTEND_URL_VAL=$(echo "$SECRET_RESPONSE" | jq -r '.data.data.FRONTEND_URL // "http://localhost:8080"')

        if [ -z "$FIREBASE_JSON" ] || [ "$FIREBASE_JSON" == "null" ]; then
          echo "::error::FIREBASE_ADMIN_SDK_JSON not found in Vault"; exit 1;
        fi

        echo "Fetched backend secrets."
        echo "::add-mask::$FIREBASE_JSON"

        echo "DEPLOY_FRONTEND_URL=$FRONTEND_URL_VAL" >> $GITHUB_ENV

        echo "firebase_json<<EOF" >> $GITHUB_OUTPUT
        echo "$FIREBASE_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        echo "Backend secrets processed."

    - name: Fetch Frontend Secrets from Vault
      id: fetch-frontend-secrets
      run: |
        echo "Fetching secrets from ${{ env.FRONTEND_SECRETS_PATH }}"
        SECRET_RESPONSE=$(curl -fsS -H "X-Vault-Token: $VAULT_TOKEN" \
             "${{ env.VAULT_ADDR }}/v1/${{ env.FRONTEND_SECRETS_PATH }}")

        if ! echo "$SECRET_RESPONSE" | jq -e '.data.data' > /dev/null; then
          echo "::error::Failed to fetch frontend secrets or data is empty. Response:"
          echo "$SECRET_RESPONSE"
          exit 1
        fi

        echo "Fetched frontend secrets. Exporting VITE_ variables..."
        echo "$SECRET_RESPONSE" | jq -r '.data.data | to_entries[] | select(.key | startswith("VITE_")) | "\(.key)=\(.value)"' >> $GITHUB_ENV

        API_BASE_URL_CHECK=$(echo "$SECRET_RESPONSE" | jq -r '.data.data.VITE_API_BASE_URL // ""')
        if [ -z "$API_BASE_URL_CHECK" ]; then
            echo "::warning::VITE_API_BASE_URL not found or empty in Vault, setting default '/api' in GITHUB_ENV."
            # Explicitly set the default in GITHUB_ENV if it wasn't found above
            echo "VITE_API_BASE_URL=/api" >> $GITHUB_ENV
        else
             # Optional: Echo the value found if you want confirmation
             echo "VITE_API_BASE_URL found in Vault and exported."
        fi

        echo "Frontend VITE_ variables prepared for GITHUB_ENV."
    
    - name: Verify Frontend Secrets Export
      run: |
        echo "Verifying essential frontend environment variables..."
        if [ -z "${{ env.VITE_FIREBASE_API_KEY }}" ]; then
           echo "::error::Verification failed: VITE_FIREBASE_API_KEY was not set in environment."
           exit 1
        else
          echo "VITE_FIREBASE_API_KEY=*** (Verified)"
        fi
        echo "Frontend environment variables verified."
        echo "Frontend VITE_ variables exported."
        

    # 3. Set up Docker Buildx
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # 4. (Optional) Login to Docker Registry (e.g., Docker Hub or GHCR)
    #    Store credentials in GitHub Secrets (DOCKERHUB_USERNAME, DOCKERHUB_TOKEN or GHCR_PAT)
    # - name: Login to Docker Hub
    #   uses: docker/login-action@v3
    #   with:
    #     username: ${{ secrets.DOCKERHUB_USERNAME }}
    #     password: ${{ secrets.DOCKERHUB_TOKEN }}
    # - name: Login to GitHub Container Registry
    #   uses: docker/login-action@v3
    #   with:
    #     registry: ghcr.io
    #     username: ${{ github.actor }}
    #     password: ${{ secrets.GITHUB_TOKEN }} # Use default GITHUB_TOKEN

    # 5. Build and Push Docker Images (Adapt image names if using registry)
    - name: Build and Push Backend Image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: false # Set to true if pushing to a registry
        tags: ${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }},${{ env.BACKEND_IMAGE_NAME }}:latest
        load: true

    - name: Build Frontend Image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: false
        tags: ${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }},${{ env.FRONTEND_IMAGE_NAME }}:latest
        load: true 
        build-args: |
          VITE_API_BASE_URL=${{ env.VITE_API_BASE_URL }}
          VITE_FIREBASE_API_KEY=${{ env.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN=${{ env.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID=${{ env.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET=${{ env.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID=${{ env.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID=${{ env.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_MEASUREMENT_ID=${{ env.VITE_FIREBASE_MEASUREMENT_ID }}

    # 6. Deploy to Local Server via SSH
    - name: Deploy to Server
      uses: appleboy/ssh-action@v1.0.3
      env: 
         FIREBASE_JSON_OUTPUT: ${{ steps.fetch-backend-secrets.outputs.firebase_json }}
         DEPLOY_FRONTEND_URL_ACTION: ${{ env.DEPLOY_FRONTEND_URL }}
         VITE_API_BASE_URL_ACTION: ${{ env.VITE_API_BASE_URL }}
         IMAGE_TAG_ACTION: ${{ env.IMAGE_TAG }}
      with:
        host: ${{ secrets.DEPLOY_HOST }}
        username: ${{ secrets.DEPLOY_USERNAME }}
        key: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}
        port: ${{ secrets.DEPLOY_SSH_PORT || 22 }}
        # The script now uses env vars defined in the 'env:' block above
        script: |
          export DEPLOY_DIR="/home/deployer/villages-conditions" # <<< UPDATE THIS PATH
          echo "--- Deploying to ${DEPLOY_DIR} ---"
          mkdir -p $DEPLOY_DIR
          cd $DEPLOY_DIR || exit 1

          echo "--- Updating .env file ---"
          # Reference the env vars passed via the step's 'env:' block
          printf '%s\n' \
          "FRONTEND_URL=${DEPLOY_FRONTEND_URL_ACTION}" \
          "VITE_API_BASE_URL=${VITE_API_BASE_URL_ACTION}" \
          "FIREBASE_ADMIN_SDK_JSON_CONTENT='${FIREBASE_JSON_OUTPUT}'" \
          "BACKEND_IMAGE_TAG=${IMAGE_TAG_ACTION}" \
          "FRONTEND_IMAGE_TAG=${IMAGE_TAG_ACTION}" \
          > .env

          if [ ! -s .env ]; then
              echo "::error::Failed to write .env file on server."
              exit 1
          fi
          echo ".env file updated."

          # Load built images if not pushing/pulling (requires docker save/load or different strategy)
          # This part is tricky without pushing to a registry.
          # For now, assuming --build in docker compose uses local context
          # Ensure your docker-compose.yml has 'build:' contexts defined

          echo "--- Running docker compose up ---"
          # Use --build flag if you didn't push/pull images
          docker compose --env-file .env up -d --remove-orphans --force-recreate --build

          echo "--- Cleaning up dangling images ---"
          docker image prune -f

          echo "--- Deployment complete! ---"