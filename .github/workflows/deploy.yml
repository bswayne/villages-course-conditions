name: Deploy Villages Conditions App

on:
  push:
    branches: [main]

env:
  # Keep image names and tag definition
  BACKEND_IMAGE_NAME: villages-conditions-backend
  FRONTEND_IMAGE_NAME: villages-conditions-frontend
  IMAGE_TAG: ${{ github.sha }}
  VAULT_ADDR: https://vault.bcjs.us
  CLOUDFLARED_VERSION: "2024.3.0"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # 1. Set up Docker Buildx
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # 2. Build Docker Images (Pass only NON-Vault variables)
    - name: Build Backend Image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: false
        tags: ${{ env.BACKEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }},${{ env.BACKEND_IMAGE_NAME }}:latest
        load: true

    - name: Build Frontend Image
      id: build-frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: false
        tags: ${{ env.FRONTEND_IMAGE_NAME }}:${{ env.IMAGE_TAG }},${{ env.FRONTEND_IMAGE_NAME }}:latest
        load: true
        build-args: |
          VITE_API_BASE_URL=${{ secrets.PROD_VITE_API_BASE_URL }}
    
     # 3. Install Cloudflared Client on Runner
    - name: Install Cloudflared
      run: |
       wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -O cloudflared.deb
       sudo dpkg -i cloudflared.deb
       cloudflared --version
    
    - name: Setup SSH Configuration
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" > ~/.ssh/id_deploy_server
        chmod 600 ~/.ssh/id_deploy_server
        cat <<EOF > ~/.ssh/config
        Host deploy-server-via-tunnel
          HostName ${{ secrets.DEPLOY_HOST }}
          User ${{ secrets.DEPLOY_USERNAME }}
          IdentityFile ~/.ssh/id_deploy_server
          ProxyCommand /usr/local/bin/cloudflared access ssh --hostname %h
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
        EOF
        chmod 600 ~/.ssh/config
        echo "SSH config written for deploy-server-via-tunnel"
    

    # 5. Deploy to Server via SSH
    - name: Deploy to Server
      uses: appleboy/ssh-action@v1.0.3
      env: # Pass only necessary vars FROM Action TO Remote Script
         IMAGE_TAG_ACTION: ${{ env.IMAGE_TAG }}
         VAULT_ADDR_ACTION: ${{ env.VAULT_ADDR }} # Pass Vault address if not set on server
         VITE_API_BASE_URL_ACTION: ${{ secrets.PROD_VITE_API_BASE_URL }}
      with:
        host: deploy-server-via-tunnel 
        username: ${{ secrets.DEPLOY_USERNAME }} # User is implicitly defined by ssh config
        key: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }} # Key is implicitly defined by ssh config
        port: ${{ secrets.DEPLOY_SSH_PORT || 22 }}
        # Put the SERVER-SIDE script here
        script: |
          set -e
          export DEPLOY_DIR="/home/bswayne/villages-conditions"
          export VAULT_ADDR="${VAULT_ADDR_ACTION}"
          ROLE_ID_PATH="/etc/vault/approle_role_id"
          SECRET_ID_PATH="/etc/vault/approle_secret_id"

          echo "--- Deploying to ${DEPLOY_DIR} ---"
          # Create dir if needed, then CD
          mkdir -p "$DEPLOY_DIR"
          cd "$DEPLOY_DIR" || { echo "::error::Failed to cd into ${DEPLOY_DIR}"; exit 1; }

          # Optional: Update code context if building on server
          echo "--- Updating source code via git (optional) ---"
          # git pull origin main # Uncomment if applicable

          # 1. Authenticate to Vault from server
          echo "--- Authenticating to Vault from server ---"
          if [ ! -r "$ROLE_ID_PATH" ]; then echo "::error::RoleID file not found or not readable at $ROLE_ID_PATH"; exit 1; fi
          if [ ! -r "$SECRET_ID_PATH" ]; then echo "::error::SecretID file not found or not readable at $SECRET_ID_PATH"; exit 1; fi
          VAULT_ROLE_ID=$(cat "$ROLE_ID_PATH")
          VAULT_SECRET_ID=$(cat "$SECRET_ID_PATH")
          if [ -z "$VAULT_ROLE_ID" ] || [ -z "$VAULT_SECRET_ID" ]; then echo "::error::Failed to read RoleID/SecretID"; exit 1; fi
          VAULT_TOKEN=$(vault write -field=token auth/approle/login role_id="$VAULT_ROLE_ID" secret_id="$VAULT_SECRET_ID")
          if [ -z "$VAULT_TOKEN" ]; then echo "::error::Vault AppRole login failed"; exit 1; fi
          echo "Vault AppRole login successful (Token expires soon)."

          # 2. Fetch secrets & write .env
          echo "--- Fetching secrets and updating .env file ---"
          BACKEND_SECRETS=$(vault kv get -token="$VAULT_TOKEN" -format=json secret/ci/villages-conditions/backend)
          FRONTEND_SECRETS=$(vault kv get -token="$VAULT_TOKEN" -format=json secret/ci/villages-conditions/frontend) # Needed for FRONTEND_URL for backend CORS

          FIREBASE_JSON_CONTENT=$(echo "$BACKEND_SECRETS" | jq -r '.data.data.FIREBASE_ADMIN_SDK_JSON')
          FRONTEND_URL_VAL=$(echo "$BACKEND_SECRETS" | jq -r '.data.data.FRONTEND_URL // "http://localhost:8080"')
          # API_URL_VAL=$(echo "$FRONTEND_SECRETS" | jq -r '.data.data.VITE_API_BASE_URL // "/api"') # We get this from Action env now

          if [ -z "$FIREBASE_JSON_CONTENT" ] || [ "$FIREBASE_JSON_CONTENT" == "null" ]; then echo "::error::Failed to get FIREBASE_ADMIN_SDK_JSON from Vault"; exit 1; fi

          # Write .env - use IMAGE_TAG_ACTION and VITE_API_BASE_URL_ACTION passed from Action env
          printf '%s\n' \
          "FRONTEND_URL=${FRONTEND_URL_VAL}" \
          "VITE_API_BASE_URL=${VITE_API_BASE_URL_ACTION}" \ # Used by backend CORS
          "FIREBASE_ADMIN_SDK_JSON_CONTENT='${FIREBASE_JSON_CONTENT}'" \
          "BACKEND_IMAGE_TAG=${IMAGE_TAG_ACTION}" \
          "FRONTEND_IMAGE_TAG=${IMAGE_TAG_ACTION}" \
          > .env
          echo ".env file updated."

          # 3. Load/Tag Docker Images built by Actions Runner? NO - Rebuilding on Server
          # If you used `load: true`, the images are on the runner's docker daemon only.
          # The `--build` flag in `docker compose` assumes source code + Dockerfiles are here.

          # 4. Run Docker Compose
          echo "--- Running docker compose up ---"
          docker compose --env-file .env up -d --remove-orphans --force-recreate --build

          # 5. Clean up
          echo "--- Cleaning up dangling images ---"
          docker image prune -f

          echo "--- Deployment complete! ---"